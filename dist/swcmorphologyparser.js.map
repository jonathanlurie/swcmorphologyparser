{"version":3,"file":"swcmorphologyparser.js","sources":["../node_modules/morphologycorejs/dist/morphologycorejs.js","../src/Constants.js","../src/TreeNode.js","../src/TreeNodeCollection.js","../src/SwcParser.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.morphologycorejs = {})));\n}(this, (function (exports) { 'use strict';\n\n  /*\n  * Author   Jonathan Lurie - http://me.jonathanlurie.fr\n  * License  Apache License 2.0\n  * Lab      Blue Brain Project, EPFL\n  */\n\n\n  /**\n   * A section is a list of 3D points and some metadata. A section can have one parent\n   * and multiple children when the dendrite or axone divide into mutliple dendrites\n   * and axons.\n   * A section instance can be built from scratch of it can be built using a raw object,\n   * usually from a JSON description.\n   */\n  class Section {\n\n\n    /**\n     * To construct a section, we need a reference to the morphology instance that\n     * 'hosts' them. This may seem a bit a bit counter intuitive to have a reference\n     * in that direction but it can be very convenient, when knowing a section, to\n     * know to which morphology it belongs (i.e. raycasting a section)\n     * @param {Morphology} morphology - the Morphology instance that host _this_ section\n     */\n    constructor (morphology=null) {\n      this._id = null;\n      this._parent = null;\n      this._children = [];\n      this._typename = null;\n      this._typevalue = null;\n      this._points = null;\n      this._radiuses = null;\n      this._morphology = morphology;\n\n\n      /*\n      Standardized swc files (www.neuromorpho.org)\n      0 - undefined\n      1 - soma\n      2 - axon\n      3 - (basal) dendrite\n      4 - apical dendrite\n      5+ - custom\n      */\n      this._typevalueToTypename = {\n        \"0\" : \"undefined\",\n        \"1\" : \"soma\",\n        \"2\" : \"axon\",\n        \"3\" : \"basal_dendrite\",\n        \"4\" : \"apical_dendrite\",\n        \"5\" : \"custom\"\n      };\n\n      this._typenameToTypevalue = {\n        \"undefined\" : 0,\n        \"soma\" : 1,\n        \"axon\" : 2,\n        \"basal_dendrite\" : 3,\n        \"apical_dendrite\" : 4,\n        \"custom\" : 5\n      };\n    }\n\n\n    /**\n     * Defines the id of this seciton.\n     * Note: should probably not be used after `initWithRawSection` because then\n     * sections already have ids and chance to messup the id game are pretty high.\n     * @param {String|Number} id - the id\n     */\n    setId (id) {\n      this._id = id;\n    }\n\n\n    /**\n     * Get the id of _this_ section\n     * @return {String|Number}\n     */\n    getId () {\n      return this._id\n    }\n\n\n    /**\n     * Define the typename, like in the SWC spec. Must be one of:\n     *  - \"undefined\"\n     *  - \"soma\" (even though this one should be used to build a Soma instance)\n     *  - \"axon\"\n     *  - \"basal_dendrite\"\n     *  - \"apical_dendrite\"\n     *  - \"custom\"\n     * Not that this method automaically sets the typevalue accordingly.\n     * For more info, go to http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html\n     * @param {String} tn - the typename\n     */\n    setTypename (tn) {\n      if (tn in this._typenameToTypevalue) {\n        this._typename = tn;\n        this._typevalue = this._typenameToTypevalue[tn];\n      } else {\n        console.warn( \"The typename must be one of \" + Object.key(this._typenameToTypevalue).join(\" \") );\n      }\n    }\n\n\n    /**\n     * Get the typename as a String\n     * @return {String}\n     */\n    getTypename () {\n      return this._typename\n    }\n\n\n    /**\n     * Defnies the typevalue, which is the integer that goes in pair with the type name.\n     * According to SWC spec. Must be one of:\n     * - 0, for undefined\n     * - 1, for soma (even though this one should be used to build a Soma instance)\n     * - 2, for axon\n     * - 3, for basal dendrite\n     * - 4, for apical dendrite\n     * - 5, for custom\n     * Note that defining the type value will automatically set the type name accordingly.\n     * @param {Number} tv - the type value\n     */\n    setTypeValue (tv) {\n      this._typevalue = tv;\n    }\n\n\n    /**\n     * Get the type value\n     * @return {Number}\n     */\n    getTypevalue () {\n      return this._typevalue\n    }\n\n\n    /**\n     * Add a point to _this_ current section\n     * @param {Number} x - the x coordinate of the point to add\n     * @param {Number} y - the y coordinate of the point to add\n     * @param {Number} z - the z coordinate of the point to add\n     * @param {Number} r - the radius at the point to add. (default: 1)\n     */\n    addPoint (x, y, z, r=1) {\n      this._points.push( [x, y, z] );\n      this._radiuses.push( r );\n    }\n\n\n    /**\n     * Get all the points of _this_ section as an array\n     * @return {Array} each element are of form [x: Number, y: Number, y: Number]\n     */\n    getPoints () {\n      return this._points\n    }\n\n\n    /**\n     * Get all the radiuses of the point in _this_ section\n     * @return {Array}\n     */\n    getRadiuses () {\n      return this._radiuses\n    }\n\n\n    /**\n     * Build a section using a raw section object.\n     * @param {Object} rawSection - usually comes from a JSON file\n     */\n    initWithRawSection (rawSection) {\n      this._id = rawSection.id;\n\n      this._points = rawSection.points.map( function(p){return p.position});\n      this._radiuses = rawSection.points.map( function(p){return p.radius});\n\n      // in some cases, we have only the typename or the typevalue, in this case we perform  a lookup\n      if (rawSection.typename || rawSection.typevalue) {\n        this._typename = rawSection.typename || this._typevalueToTypename[rawSection.typevalue];\n        this._typevalue = rawSection.typevalue || this._typenameToTypevalue[rawSection.typename];\n      }\n\n      return this._id\n    }\n\n\n    /**\n     * Define the parent section of _this_ section, as an object reference.\n     * The only verification perfomed by this method is that a section is not added\n     * as its own parent.\n     * @param {Section} section - the section that is the parent of this one\n     * @return {Boolean} true if parent was successfully defined, false if not.\n     */\n    setParent (section) {\n      if (section && section.getId() !== this._id) {\n        this._parent = section;\n        return true\n      }\n\n      console.warn( \"A section cannot be the parent of itself.\");\n      return false\n    }\n\n\n    /**\n     * Get the parent section of _this_ section\n     * @return {Section} the parent\n     */\n    getParent () {\n      return this._parent\n    }\n\n\n    /**\n     * Make a given section the child of _this_ one.\n     * Two verifications are perfomed before: ids must be diferent so that we are\n     * not allowing a section to be the child of itself, and that _this_ section\n     * does not already have the given section as a children (=> avoid doublons)\n     * @param {Section} section - The section to add as a child\n     * @return {Boolean} true if successfully added (of if already has the given child),\n     * false if the candidate cannot be a child\n     */\n    addChild (section) {\n      if (section.getId() !== this._id) {\n        if (this.hasChild(section)) {\n          console.warn(\"The given section is already one of the child to this one.\");\n        } else {\n          this._children.push( section );\n        }\n        return true\n\n      } else {\n        console.warn(\"A section cannot be the child of itself.\");\n        return false\n      }\n\n      return true\n    }\n\n\n    /**\n     * Checks if a given section is already one of the children of _this_ section\n     * @param {Section} section - a section to test\n     * @return {Boolean} true if the given section is already a child of _this_ section, false if not.\n     */\n    hasChild (section) {\n      if (!this._children)\n        return false\n\n      let candidateId = section.getId();\n\n      for (let i=0; i<this._children.length; i++) {\n        if (this._children[i].getId() === candidateId)\n          return true\n      }\n\n      return false\n    }\n\n\n  }\n\n  /*\n  * Author   Jonathan Lurie - http://me.jonathanlurie.fr\n  * License  Apache License 2.0\n  * Lab      Blue Brain Project, EPFL\n  */\n\n\n\n  /**\n   * The soma is the cell body of a neurone and thus is sort of a simplified version\n   * of a Section, in term of datastructure.\n   * A soma can be made of a single point (then it's just a center point) or of several,\n   * then it's a more accurate description of a soma. When described with several points,\n   * the representation is usually as a 2D polygon (even though it's in a 3D space)\n   */\n  class Soma {\n    constructor () {\n      this._id = null;\n      this._typename = \"soma\";\n      this._typevalue = 1;\n      this._points = [];\n      this._radius = null;\n    }\n\n    /**\n     * Defines the id of this soma.\n     * Note: should probably not be used after `initWithRawSection` because then\n     * sections already have ids and chance to messup the id game are pretty high.\n     * @param {String|Number} id - the id\n     */\n    setId (id) {\n      this._id = id;\n    }\n\n\n    /**\n     * Get the id of _this_ soma\n     * @return {String|Number}\n     */\n    getId () {\n      return this._id\n    }\n\n\n    /**\n     * Add a point to the soma description\n     * @param {Number} x - the x coordinate of the point to add\n     * @param {Number} y - the y coordinate of the point to add\n     * @param {Number} z - the z coordinate of the point to add\n     */\n    addPoint (x, y, z) {\n      this._points.push( [x, y, z]);\n    }\n\n\n    /**\n     * Get all the points of the soma\n     * @return {Array} each element of the array if of form [x: Number, y: Number, z: Number]\n     */\n    getPoints () {\n      return this._points\n    }\n\n\n    /**\n     * Define the radius of the soma\n     * @param {Number} r - the radius\n     */\n    setRadius (r) {\n      this._radius = r;\n    }\n\n\n    /**\n     * Get the radius of the soma.\n     * @return {Number}\n     */\n    getRadius () {\n      return this._radius\n    }\n\n\n    /**\n     * Return the center of the soma.\n     * If the soma is made of a single point and a radius, this method returns the\n     * single point. If the soma is made of several points, this method returns the\n     * average.\n     * @return {Array|null} coordinate of the center as [x: Number, y: Number, z: Number]\n     */\n    getCenter () {\n      let nbPoints = this._points.length;\n\n      if (nbPoints === 1) {\n        return this._points[0].slice()\n      } else if (nbPoints > 1){\n\n        let average = [0, 0, 0];\n        for (let i=0; i<nbPoints; i++) {\n          average[0] += this._points[i][0];\n          average[1] += this._points[i][1];\n          average[2] += this._points[i][2];\n        }\n        average[0] /= nbPoints;\n        average[1] /= nbPoints;\n        average[2] /= nbPoints;\n        return average\n\n      } else {\n        return null\n      }\n    }\n\n\n    /**\n     * Build a soma using a raw soma object.\n     * @param {Object} rawSoma - usually comes from a JSON file\n     */\n    initWithRawSection (rawSoma) {\n      this._id = rawSoma.id;\n      this._points = rawSoma.points.map( function(p){return p.position});\n      this._radius = rawSoma.radius;\n\n      return this._id\n    }\n  }\n\n  /*\n  * Author   Jonathan Lurie - http://me.jonathanlurie.fr\n  * License  Apache License 2.0\n  * Lab      Blue Brain Project, EPFL\n  */\n\n\n  /**\n   * A morphology is the data representation of a neurone's anatomy. It is composed\n   * of one soma (cell body) and sections. Sections can be axons, dendrites, etc.\n   * A Morphology instance can be built from scratch (though it can be a bit tedious)\n   * but will generally be built using a JSON description.\n   */\n  class Morphology {\n\n    constructor () {\n      this._id = null;\n      this._sections = {};\n      this._soma = null;\n\n      // these are catgories of sections that we may need. Look at `getOrphanSections`\n      // and `_findSpecialSection`\n      this._specialSections = {};\n    }\n\n\n    /**\n     * Set the ID of _this_ morphology\n     * @param {String|Number} id - the id\n     */\n    setId (id) {\n      this._id = id;\n    }\n\n\n    /**\n     * Get the ID of _this_ morphology\n     * @return {String|Number}\n     */\n    getId () {\n      return this._id\n    }\n\n\n    /**\n     * Build a morphology from a raw dataset, that usually comes from a JSON file.\n     *\n     */\n    buildFromRawMorphology (rawMorphology) {\n      let that = this;\n\n      this._soma = new Soma();\n      this._soma.initWithRawSection( rawMorphology.soma );\n\n      // Build the Section instances.\n      // This first step does not define parents nor children\n      for (let i=0; i<rawMorphology.sections.length; i++) {\n        let s = new Section();\n        let sId = s.initWithRawSection( rawMorphology.sections[i] );\n        this._sections[ sId ] = s;\n      }\n\n      // Now we define parent and children\n      for (let i=0; i<rawMorphology.sections.length; i++) {\n        let currentRawSection = rawMorphology.sections[i];\n        let currentSection = this._sections[ currentRawSection.id ];\n\n        // adding a parent if there is one\n        if (currentRawSection.parent){\n          let parent = this._sections[ currentRawSection.parent ];\n          currentSection.setParent( parent );\n        }\n\n        let children = currentRawSection.children.map(function(c){return that._sections[ c ]});\n        for (let c=0; c<children.length; c++) {\n          currentSection.addChild( children[c] );\n        }\n      }\n    }\n\n\n    /**\n     * Retrieve the total number of section in this morphology\n     * @return {Number}\n     */\n    getNumberOfSections () {\n      return Object.keys( this._sections )\n    }\n\n\n    /**\n     * Get a section, given its id\n     * @param {String|Number} id - the id of a section\n     * @return {Section|null} the requested section or null if the id is invalid\n     */\n    getSection (id) {\n      if (id in this._sections) {\n        return this._sections[id]\n      }else{\n        return null\n      }\n    }\n\n\n    /**\n     * Get all the sections of _this_ morphology as an array, because sometimes it's\n     * more convenient for iterating.\n     * @return {Array} array of Section instances\n     */\n    getArrayOfSections () {\n      return Object.values( this._sections )\n    }\n\n\n    /**\n     * Get the soma Object\n     * @return {Soma}\n     */\n    getSoma () {\n      return this._soma\n    }\n\n\n    /**\n     * Get all the section with no parent (_parent = null)\n     * Those are directly tied to the soma\n     * @param {Boolean} force - if true, the fetching among the sections will be done again\n     * @return {Array} array of Sections\n     */\n    getOrphanSections (force=false) {\n      let speciality = \"orphans\";\n\n      // extract, if not done before\n      this._findSpecialSection(\n        \"orphans\",\n        function(s){\n          return !s.getParent()\n        },\n        force\n      );\n\n      return this._specialSections[speciality]\n    }\n\n\n\n    /**\n     * @private\n     * Helper function to build a subset of Sections based on the selections perfomed by `selector`\n     * @param {String} specialityName - name of the spaciality\n     * @param {Function} selector - function that takes a Section and returns a boolean.\n     * if true is return, a section will be selected\n     * @param {Boolean} force - if true: rebuild the list, if false: just return the list previously build\n     */\n    _findSpecialSection (specialityName, selector, force=false) {\n      if (!(specialityName in this._specialSections)) {\n        this._specialSections[specialityName] = null;\n      }\n\n      if (force || !this._specialSections[specialityName]) {\n        this._specialSections[specialityName] = [];\n        let allSections = Object.values( this._sections );\n        for (let i=0; i<allSections.length; i++) {\n          if (selector(allSections[i])) {\n            this._specialSections[specialityName].push(allSections[i]);\n          }\n        }\n      }\n      return this._specialSections[specialityName]\n    }\n\n  }\n\n  exports.Morphology = Morphology;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","/**\n * Defines the SWC standard types as in http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html\n */\nconst SWC_TYPES = {\n  UNDEFINED: 0,\n  SOMA: 1,\n  AXON: 2,\n  BASAL_DENDRITE: 3,\n  APICAL_DENDRITE: 4,\n  CUSTOM: 5\n}\n\nexport { SWC_TYPES }\n","import { SWC_TYPES } from \"./Constants.js\"\n\n\n/**\n * A TreeNode instance represent a point from the SWC file. It has a 3D coordinate,\n * an ID, a type, a radius, a reference to a parent (which is also a TreeNode\n * instance) and a list of children (also TreeNode instances).\n *\n * **Ressources**\n * - [SWC Spec](http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html)\n */\nclass TreeNode {\n\n  /**\n   * @param {Number} id - the id of the point\n   * @param {Number} type - type of structure this point comes from (cf. SWC spec)\n   * @param {Number} x - x component of the 3D coordinates\n   * @param {Number} y - y component of the 3D coordinates\n   * @param {Number} z - z component of the 3D coordinates\n   * @param {Number} r - radius at this given point\n   */\n  constructor (id, type, x, y, z, r ) {\n    this._id = id\n    this._type = type\n    this._position = [x, y, z]\n    this._radius = r\n\n    this._parent = null\n    this._children = []\n\n    this._hasSomaChildren = false\n  }\n\n\n  /**\n   * Get the ID of _this_ node\n   * @return {Number}\n   */\n  getId () {\n    return this._id\n  }\n\n\n  /**\n   * Get the type as a number (according to the SWC spec)\n   * @return {Number}\n   */\n  getType () {\n    return this._type\n  }\n\n\n  /**\n   * @return {Boolean} true if this node is a soma, false if not\n   */\n  isSoma () {\n    return (this._type === SWC_TYPES.SOMA)\n  }\n\n  /**\n   * Get teh radius of _this_ node\n   * @return {Number}\n   */\n  getRadius () {\n    return this._radius\n  }\n\n\n  /**\n   * Get the 3D coordinates of this node\n   */\n  getPosition () {\n    return this._position\n  }\n\n  /**\n   * Define the parent of _this_ node\n   * @param {TreeNode} parent - the parent node\n   */\n  setParent (pNode) {\n    this._parent = pNode\n    pNode._addChild(this)\n  }\n\n\n  /**\n   * Get the parent node of _this_ one\n   * @return {TreeNode}\n   */\n  getParent () {\n    return this._parent\n  }\n\n\n  /**\n   * @private\n   * Add a child to _this_ node\n   * @param {TreeNode} cNode - a node to add as a child of _this_\n   */\n  _addChild (cNode) {\n    if (!this.doesAlreadyHaveChild(cNode)) {\n      this._children.push(cNode)\n\n      this._hasSomaChildren = cNode.isSoma() || this._hasSomaChildren\n    }\n  }\n\n\n  /**\n   * Get all the chidren\n   * @return {Array} array of TreeNode instances\n   */\n  getChildren () {\n    return this._children\n  }\n\n\n  /**\n   * Get all the children that are not soma points.\n   * @return {Array} array of TreeNode instances\n   */\n  getNonSomaChildren () {\n    if (!this._hasSomaChildren) {\n      return this._children\n    }\n\n    let nonSomaChildren = []\n\n    for (let i=0; i<this._children.length; i++) {\n      if (!this._children[i].isSoma()) {\n        nonSomaChildren.push(this._children[i])\n      }\n    }\n    return nonSomaChildren\n  }\n\n\n  /**\n   * Check is _this_ node already has the given child amond its list of children\n   * @param {TreeNode} cNode - some node to test, most likely a potential child\n   * @return {Boolean} true if this child is already present, false if not\n   */\n  doesAlreadyHaveChild (cNode) {\n    for (let i=0; i<this._children.length; i++) {\n      if (this._children[i].getId() === cNode.getId())\n        return true\n    }\n    return false\n  }\n\n\n  /**\n   * Dive into the TreeNode connection by following the children. Builds a list\n   * all along. Stops when a node has no more children (end of branch) or when a\n   * node has two children or more because it means it's a forking point.\n   * What is returned in the end is an array that can be empty (if end of branch)\n   * or with two or more TreeNode instance being the forking direction\n   * @param {Array} nodeList - contains the previous TreeNode (parent, grand parents, etc.)\n   * this array is only pushed to, nothing is taken or read from it.\n   * @return {Array} of TreeNodes that are forking direction.\n   */\n  dive (nodeList) {\n    // adding the current node on the list\n    nodeList.push(this)\n\n    let children = this.getNonSomaChildren()\n\n    // this current node is in the middle of a sections, we go on...\n    if (children.length === 1) {\n\n      if (children[0].getType() === this._type) {\n        return children[0].dive(nodeList)\n      } else {\n        console.warn(`Non-soma node (id:${this._id} type:${this._type}) has a single child of different type (id:${children[0].getId()} type:${this.getType()})`)\n      }\n\n\n    // this is or a ending point (no children) or a forking point (2 children or more).\n    // In both case, this the end of a sections\n    } else {\n      return children\n    }\n  }\n\n}\n\nexport { TreeNode }\n","import morphologycorejs from 'morphologycorejs'\nimport { TreeNode } from \"./TreeNode.js\"\nimport { SWC_TYPES } from \"./Constants.js\"\n\n\n/**\n * A TreeNodeCollection instance builds all the TreeNode instances from the raw\n * points list from the SWC file. As a second step, it builds the parent/children\n * relations between the nodes and as a third step, define a list of sections.\n */\nclass TreeNodeCollection {\n\n  /**\n   * @param {Array} points - every points of the array is itself an Array of form:\n   * [\n   *     pointId: Number,\n   *     pointType: Number,\n   *     x: Number,\n   *     y: Number,\n   *     z: Number,\n   *     radius: Number,\n   *     parentId: Number\n   *   ]\n   */\n  constructor (points) {\n    this._nodes = {}\n    this._rawSoma = null\n    this._rawSections = null\n    this._rawMorphology = null\n    this._morphology = null\n    this._initCollection(points)\n    this._buildSections()\n    this._buildRawMorphology()\n  }\n\n\n  /**\n   * Get the raw morphology flat tree\n   * @return {Object} the soma and all the sections at the same level.\n   * Still, all the info about parent/children are present\n   */\n  getRawMorphology () {\n    return this._rawMorphology\n  }\n\n\n  /**\n   * Get the morphology object, which is much easier to query than the raw morphology\n   * @return {morphologycorejs.Morphology}\n   *\n   */\n  getMorphology () {\n    return this._morphology\n  }\n\n\n  /**\n   * @private\n   * Makes the list of nodes\n   */\n  _initCollection (points) {\n    let somaNodes = []\n\n    for (let i=0; i<points.length; i++) {\n      let aNode = new TreeNode(\n        points[i][0], // id\n        points[i][1], // type\n        points[i][2], // x\n        points[i][3], // y\n        points[i][4], // z\n        points[i][5], // radius\n      )\n\n      this._nodes[points[i][0]] = aNode\n\n      // The soma nodes: in addition to put them in the regular collection,\n      // we also put them in a small collection we keep on the side\n      if (points[i][1] === SWC_TYPES.SOMA) {\n        somaNodes.push(aNode)\n      }\n\n      // In the SWC, a node/point seems to be always described after its parent,\n      // so we can makes the parent/children links in the same loop\n      let parentId = points[i][6]\n\n      // the first point of the soma has no parent\n      if (parentId === -1)\n        continue\n\n      let theParentNode = this._nodes[ parentId ]\n      aNode.setParent( theParentNode )\n    }\n\n    // build the soma if we have some soma points\n    if (somaNodes.length) {\n      this._rawSoma = {\n        id: 0, // just to have the same format as the NeuroM converter\n        type: \"soma\",\n        // the radius are usually all the same, but just in case, we take the largest one\n        radius: Math.max( ...somaNodes.map(function(n){return n.getRadius()}) ),\n        points: somaNodes.map(function(n){return {position: n.getPosition()}})\n      }\n    }\n  }\n\n\n  /**\n   * @private\n   * Reconstruct all the section from the nodes, give them IDs and establish the\n   * parent/children relationship\n   */\n  _buildSections () {\n    let currentSectionId = 0\n    let sections = []\n\n    // find the first node that has non-soma children:\n    let firstValidNode = null\n    let firstValidChildren = []\n    for (let nodeId in this._nodes) {\n      let childrenOfNode = this._nodes[nodeId].getNonSomaChildren()\n      if (childrenOfNode.length > 0) {\n        firstValidNode = this._nodes[nodeId]\n        firstValidChildren = childrenOfNode\n        break\n      }\n    }\n\n    if (!firstValidNode ) {\n      console.warn(\"No valid section here\")\n      return\n    }\n\n    let stack = []\n\n    // add all the children of the firstValidNode into the stack\n    for (let i=0; i<firstValidChildren.length; i++) {\n      stack.push({\n        node: firstValidChildren[i],\n        parentSectionId: null\n      })\n    }\n\n\n    function buildRawSection (startingNode, parentSectionId) {\n      // the nodeList is the list of node for the section we are building.\n      // Let's say it's just a simpler version of the future section object\n      let nodeList = []\n\n      // for each starting node, we actually have to start by adding its parent\n      // to start the branch from its very basis\n      if (startingNode.getParent()) {\n        nodeList.push(startingNode.getParent())\n      }\n\n      //nodeList.push(startingNode)\n      //let nextNodes = startingNode.getNonSomaChildren()[0].dive(nodeList)\n\n      let nextNodes = startingNode.dive(nodeList)\n\n      let points = nodeList.map(function(n){\n        return {\n          position: n.getPosition(),\n          radius: n.getRadius()\n        }\n      })\n\n      // if the first point is a soma point, we dont keep the first radius\n      // because it's the radius of the soma\n      if (parentSectionId === null && points.length) {\n        points[0].radius = 0\n      }\n\n      // now nodeList is full of nodes\n      let section = {\n        typevalue: startingNode.getType(),\n        typename: null, //\n        points: points,\n        id: currentSectionId,\n        children: [],\n        parent: parentSectionId\n      }\n\n      // adding this section as a child of its parent\n      // (this is made possible because the parents are always defined before their children)\n      if (parentSectionId) {\n        sections[parentSectionId].children.push(currentSectionId)\n      }\n\n      // adding the next nodes as new section starting points\n      for (let i=0; i<nextNodes.length; i++) {\n        stack.push({\n          node: nextNodes[i],\n          parentSectionId: currentSectionId\n        })\n      }\n\n      currentSectionId++\n      return section\n    }\n\n    // popping the stack\n    while (stack.length) {\n      let stackElem = stack.pop()\n      let section = buildRawSection(stackElem.node, stackElem.parentSectionId)\n      sections.push( section )\n      sections[section.id] = section\n    }\n\n    if (sections.length) {\n      this._rawSections = sections\n    }\n\n  }\n\n\n  /**\n   * @private\n   * Performs some verification and then assemble the raw morphology\n   */\n  _buildRawMorphology () {\n    // it's ok to not have any section\n    if (!this._rawSections) {\n      console.warn(\"This morphology has no section to export\")\n    }\n\n    // it's ok to not have a soma\n    if (!this._rawSoma) {\n      console.warn(\"This morphology has no soma to show\")\n    }\n\n    // but it's not ok to have nothing at all\n    if (!this._rawSections && !this._rawSoma) {\n      console.warn(\"No valid morphology data.\")\n      return\n    }\n\n    this._rawMorphology = {\n      soma: this._rawSoma,\n      sections: this._rawSections\n    }\n\n    //this._morphology = new morphologycorejs.Morphology()\n    //this._morphology.buildFromRawMorphology( this._rawMorphology )\n  }\n\n}\n\nexport { TreeNodeCollection }\n","import { TreeNodeCollection } from './TreeNodeCollection.js'\n\n\nclass SwcParser {\n\n  constructor () {\n    this._morphology = null\n    this._rawMorphology = null\n  }\n\n\n  parse (swcStr) {\n    this._morphology = null\n    this._rawMorphology = null\n    let rawPoints = this._extractPoints(swcStr)\n    let treeNodeCollection = new TreeNodeCollection(rawPoints)\n    this._morphology = treeNodeCollection.getMorphology()\n    this._rawMorphology = treeNodeCollection.getRawMorphology()\n  }\n\n\n  /**\n   * Get the raw morphology flat tree\n   * @return {Object} the soma and all the sections at the same level.\n   * Still, all the info about parent/children are present\n   */\n  getRawMorphology () {\n    return this._rawMorphology\n  }\n\n\n  /**\n   * Get the morphology object, which is much easier to query than the raw morphology\n   * @return {morphologycorejs.Morphology}\n   *\n   */\n  getMorphology () {\n    return this._morphology\n  }\n\n\n  /**\n   * @private\n   * build an Array of points from the SWC string.\n   * Each element of the array is itself an Array representing a point and it's metadata.\n   * A single point is an Array of form:\n   *   [\n   *     pointId: Number,\n   *     pointType: Number,\n   *     x: Number,\n   *     y: Number,\n   *     z: Number,\n   *     radius: Number,\n   *     parentId: Number\n   *   ]\n   * @param {String} swcStr - the string from the SWC file\n   * @return {Array} all the points\n   */\n  _extractPoints (swcStr) {\n    // remove header/comments from SWC\n    let result = swcStr.replace(/\\s*#.*?$/mg,'')\n    // remove empty lines and empty last line\n    result = result.trim().replace(/^\\s*$/mg,'')\n\n    // store the data in memory-efficient typed arrays\n    let lines = result.split('\\n')\n    let swcPoints = []\n\n    for (let i=0; i<lines.length; i++) {\n      let row = lines[i].replace(/^\\s+/m,'').replace(/\\s+$/m,'').split(/[\\s,]+/)\n      if (row.length >= 7) {\n        // allow for sloppy SWC that contains integers written as floats\n        swcPoints[i] = [\n          Math.round(parseFloat(row[0])),\n          Math.round(parseFloat(row[1])),\n          parseFloat(row[2]),\n          parseFloat(row[3]),\n          parseFloat(row[4]),\n          parseFloat(row[5]),\n          Math.round(parseFloat(row[6]))\n        ]\n      }\n    }\n\n    return swcPoints\n  }\n\n\n}\n\nexport { SwcParser }\n"],"names":["this"],"mappings":"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"}